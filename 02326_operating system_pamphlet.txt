


(操作系统)是计算机系统中的一个系统软件，它是这样一些程序模块的集合： 它们能有效地组织和管理计算机系统中的硬件及软件资源，合理地
组织计算机工作流程，控制程序的执行，并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，并使整个计算机系统能高效地运行。




作为一种系统软件，操作系统有着与其他软件相比所不同的特征：
1、 并发性，是指在计算机系统中同时存在若干个运行着的程序，从宏观上看，这些程序在同时向前推进。计算机的并发性体现在两个方面：用户程序与用户程序之间并发执行；用户程序与
操作系统程序之间并发执行。

2、 共享性，是指操作系统程序与多个用户程序共用系统中的各种资源。这种共享性是在操作系统控制下实现的。资源的共享性主要针对计算机系统中的如下几项重要资源：中央处理器、内存储器、
外存储器、外部设备。在计算机系统中，对资源的共享一般有两种形式：互斥共享和同时共享。


3、 随机性 





研究操作系统的观点： 
1、 软件的观点
2、 资源管理的观点 
3、 进程的观点 
4、 虚拟器的观点 
5、 服务提供者观点 




操作系统的功能： 
 1、 进程管理(处理器管理)。进程管理主要包括进程控制、进程同步、进程间通信和调度等几方面的内容。
 
 2、 存储管理。 具体包括内存的分配与回收、存储保护和内存扩充三项存储管理功能。
 
 3、 文件管理。 文件管理的任务是有效地支持文件的存储、检索和修改等操作，解决文件的共享、保密和保护问题，以使用户方便、安全地访问文件。
 
 4、 设备管理 
 
 5、 用户接口 
 
 
 
 
 
 除此之外，操作系统还要具备中断处理、错误处理等功能。操作系统的各功能之间并非是完全独立的，它们之间存在着相互依赖的关系。
 
 
 
 
 
 
 
 
 
 
    操作系统的体系结构：
	1、 windows操作系统的体系结构。 windows体系结构是分层的模块系统，主要层次有硬件抽象层HAL、内核、执行体和大量的子系统集合。
	
	2、 UNIX 操作系统的体系结构 。 主要包括硬件、内核、系统调用接口、应用程序。 
	
	3、 Linux 操作系统的体系结构。 Linux 系统有四个主要部分，即内核、shell 、文件系统和用户应用程序。内核、shell和文件系统形成了基本的操作系统结构，它们使得
	用户可以运行程序、管理文件并使用系统。 
	
	4、 Android 操作系统的体系结构。   Android 操作系统分为4层，从高层到低层分别是应用程序层、应用框架层、系统运行库层和Linux内核层。
	
	
	
	
	  操作系统的发展过程包括：手工操作、监控程序(早期批处理)、多道批处理、分时与实时系统、UNIX通用操作系统、个人计算机操作系统、Android操作系统。
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	    操作系统分类： 按照用户界面的使用环境和功能特征的不同，一般可以把操作系统分为三种基本类型，即批处理系统、分时系统和实时系统。随着计算机体系结构的发展，
		又出现了许多类型的操作系统，它们是个人操作系统、网络操作系统、分布式操作系统和嵌入式操作系统。 
		
		
		
		
		
		
		
		
		
		 在操作系统设计的过程中主要困难有： 设计复杂程度高、正确性难以保证和研制周期长等问题。 
		 
		 
		 
		 
		 
		 操作系统的设计过程： 
		 1、 功能设计。指的是根据系统的设计目标和使用要求，确定所设计的操作系统应具备哪些功能以及操作系统的类型。
		 2、 算法设计。 指的是根据计算机的性能和操作系统的功能，来选择和设计满足系统功能的算法和策略，并分析和估算其效能。
		 3、结构设计。指的是按照系统的功能和特性要求，选择合适的结构，使用相应结构设计方法将系统逐步地分解、抽象和综合，使操作系统结构清晰、简明、可靠、易读、易修改，
		 而且使用方便，适应性强。
		 
		 
		 
		 
		 
		 操作系统的设计目标：
		 一个高质量的操作系统应具有可靠性(正确性和健壮性)、高效性、易维护性(易读性、易扩充性、易剪裁性、易修改性)、可移植性、安全性和简明性等特征。
		 
		 
		 
		 
		 
		 软件结构研究的(对象)是组成软件的各部分划分的原则以及它们之间的关系，即(软件的构成法则和组合方法)。
		 
		 
		 
		 
		 
		 
		 操作系统结构研究的目标： 
		 1、 系统模块化
		 2、 模块标准化
		 3、 通信规范化 
		 
		 
		 
		 操作系统的结构 ：
		 1、 整体式结构。我们把这种操作系统的结构称之为模块组合结构。它的主要优点是，结构紧密，接口简单直接，系统效率较高。
		 模块组合法(或称无序模块法、模块接口法等)的缺点有： 第一，模块间转接随便，各模块互相牵连，独立性差，系统结构不清晰。
		 第二，数据基本上作为全程量处理，系统内所有模块的任一程序均可对其进行存取和修改，从而造成了各模块间有着更为隐蔽的关系。
		 第三，由于模块组合结构常以大型表格为中心，为保证数据完整性，往往采用全局封中断办法，从而限制了系统的并发性。系统中实际存在的
		 并发生也未能抽象出明确的概念，缺乏鬼哥的描述办法。所以，这种结构的可适应性比较差。
		 
		 2、 层次式结构。层次式结构就是把操作系统的所有功能模块，按功能流图的调用次序，分别将这些模块排列成若干层，各层之间
		 的模块只能是单向依赖或单向调用(如只允许上层或外层模块调用下层或内层模块)关系。
		 
		 
		 3、 微内核(客户/服务器)结构。采用客户/服务器结构模式的典型操作系统有卡内基 梅隆大学研制的Mach操作系统和Windows NT 的早期版本。这种模式的优点在于，它将系统分成若干个
		 小的并且自包含的分支(服务进程),每个分支运行在独立的用户进程中，相互之间通过规范一致的方式接收发送信息而联系起来。这种体系结构的缺陷主要是对于效率的考虑。
		 
		 
		 
		 
		  处理器一般由(运算器、控制器、一系列的寄存器以及高速缓存构成)。其中运算器实现指令中的算术和逻辑运算，是计算机计算的核心。
		  
		  在处理器内通常有两类寄存器：一类称为(用户可见寄存器)；第二类称为(控制和状态寄存器)。通常用户可见寄存器对所有程序都是可用的，由机器语言直接引用。
		  它一般包括数据寄存器(Data Register)、地址寄存器(Address Register)以及条件码寄存器。
		  
		  
		  
		  
		  
		   指令执行的基本过程： 
		   最简单的处理指令方式包括两个步骤：首先，处理器每次从存储器中读取一条指令，并在取指令完成后，根据指令类别自动将程序计数器的值变成下一条指令的地址，通常是
		   自增1；其次，取到的指令被存储在处理器的指令寄存器中，处理器于是解释并执行这条指令。
		   
		   
		   
		   
		   指令大致可以分为五类：(访问存储器指令)，它们负责处理器和存储器之间的数据传送；(I/Q指令)，它们负责处理器和I/O模块之间的数据传送和命令发送；(算术逻辑指令)，
		   有时又称为数据处理指令，用以执行有关数据的算术和逻辑操作；(控制转移指令)，这种指令可以指定一个新的指令的执行起点；(处理器控制指令)，这种指令用于修改处理器状态，
		   改变处理器工作方式等。
		   
		   
		   
		   
		   特权指令和非特权指令：(特权指令)是指在指令系统中那些只能由操作系统使用的指令。这些指令是不允许一般的用户使用的。用户只能使用非特权指令。
		   
		   
		   
		   
		   管态和目态：多数系统将处理器工作状态划分为(管态和目态) 。 前者一般指操作系统管理程序运行的状态，具有较高的特权级别，又称为内核态、特权态(特态)、系统态；
		   后者一般指用户程序运行时的状态，具有较低的特权级别，又称为用户态、普通态(普态)。
		   
		   
		   
		   
		   
		   
		     处理器工作状态的转换： 
			 1、 目态到管态的转换。(其转换的唯一途径是通过中断)。中断响应时交换中断向量，新的中断向量中的PSW的处理器状态位标志为管态。
			 
			 2、管态到目态的转换。可通过设置(PSW指令)修改程序状态字，实现从操作系统向用户程序的转换。
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			   存储器的类型：在微型计算机中使用的半导体存储器有若干种不同的类型，但基本上可划分为两类：一种是(读写型的存储器)，另一种是(只读型的存储器)。
			   所谓读写型的存储器，是指可以把数据存入其中任一地址单元，并且可在以后的任何时候把数据读出来，或者重新存入新的数据的一种存储器。另一种是只读型
			   的存储器，只能从其中读取数据，但不能随意地用普通的方法向其中写入数据。通常要向其中写入数据只能用特殊的方法进行。
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   存储器的层次结构：计算机存储系统的设计主要考虑三个问题：(容量、速度和成本)。从整个系统来看，在计算机系统中的层次化的存储体系由寄存器、高速缓存、内存储器、
			   硬盘存储器、磁带机和光盘存储器等装置构成。 
			   
			   
			   
			   I/O结构：在每台外部设备中都配有各自的I/O设备控制器，由I/O设备控制器分别控制各台外部设备的运行。
			   
			   
			   
			   
			   通道是独立于中央处理器的，专门负责数据I/O传输工作的处理单元。
			   
			   DMA技术，即直接存储器访问技术，通过系统总线中的一个独立控制单元 ———— DMA 控制器，自动地控制成块数据在内存和I/O单元之间的传送。
			   
			   
			   缓冲技术是用在外部设备与其他硬件部件之间的一种数据暂存技术，它利用存储器件在外部设备中设置了数据的一个存储区域，称为(缓冲区)。
			   
			   
			   
			   时钟部件的原理：
			   在电路中的晶体振荡器，每隔一定间隔产生固定的脉冲频率，时钟电路中的时钟寄存器依据时钟电路所产生的脉冲数，对时钟寄存器进行加1的工作。
			   时钟的用户可以分为绝对时钟和相对时钟。
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   中断与异常的概念： 中断是指处理器对系统中或系统外发生的异步事件的响应。异步事件是指无一定时序关系的随机发生的事件。(中断是由外部事件引发的，而异常则是由正在执行
			   的指令引发的)。
			   
			   
			   
			   
			   
			   中断与异常的分类：  
			   
			   典型的中断包括： 
			   1、 (时钟中断)，由处理器内部的计时器产生，允许操作系统以一定规律执行函数，如时间片到时、硬件实时钟到时等。
			   2、 (输入输出(I/O)中断)，由I/O 控制器产生，用于通知一个I/O操作的正常完成或者发生的错误。
			   3、 (控制台中断)，如系统操作员通过控制台发出命令等。
			   4、 (硬件故障中断)，如掉电、存储器校验错等硬件故障引起等。
			   
			   异常发生的时间以及位置具有确定性，典型的异常包括：
			   1、 (程序性中断)，在某些条件下由指令执行结果产生，例如算术溢出、被零除、目态程序试图执行非法指令、访问不被允许访问的存储位置、虚拟存储中的缺页等。
			   
			   2、 (访管指令异常)，目的是要求操作系统提供系统服务。
			   
			   
			   
			   几种典型中断的处理：(I/O中断、时钟中断、硬件故障中断、程序性中断和系统服务请求(自愿性中断)等) 
			   
			   
			   
			   系统调用：就是用户在程序中调用操作系统所提供的一些子功能。
			   
			   系统调用的分类：
			   1、 进程控制类系统调用。
			   2、 文件操作类系统调动。
			   3、 进程通信类系统调用。
			   4、 设备管理类系统调用 
			   5、 信息维护类系统调用 
			   
			   
			   
			   
			   
			   
			   
			   程序的顺序执行的特点：
			   1、 顺序性 
			   2、 封闭性 
			   3、  程序执行结果的(确定性)
			   4、 程序执行结果的(可再先性)
			   
			   
			   
			   
			   程序的并发执行的特点： 
			   1 、 在执行期间并发程序相互制约。
			   2、 程序与计算不再一一对应。
			   3、 并发程序的执行结果不可再现。
			   4、 程序的并行执行与程序的并发执行。
			   
			   
			   
			   
			   多道程序设计环境具有以下特点：(独立性、随机性、资源共享性)。
			   
			   
			   多道程序设计的缺陷：
			   1、 可能延长程序的执行时间
			   2、 系统效率的提高有一定限度。
			   
			   
			   
			   
			   
			   进程的定义：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单元。(程序是静态的，而进程是动态的)。
			   
			   
			   进程的特征：
			   1、 并发性  
			   2、 动态性 
			   3、 独立性 
			   4、 交往性 
			   5、 异步性 
			   6、 结构性。  一个进程由(程序、数据和进程控制块)三部分组成。 
			   
			   
			   
			   
			   
			   
			   
			   
			   
			    三状态进程模型：
				1、 (运行状态)，是指进程已获得处理器，并且在处理器上执行的状态。显然，在一个单处理器系统中，最多只有一个进程处于运行态。
				
				2、 (就绪状态)，是指一个进程已经具备运行条件，但由于没有获得处理器而不能运行所处的状态。一旦把处理器分配给它，该进程就可运行。处于就绪状态的进程可以是多个。
				3、(等待状态)，也称为阻塞状态或封锁状态，是指进程因等待某种事件发生而暂时不能运行的状态。 
				
				三种基本状态之间的转换：(就绪->运行、运行->就绪、运行->等待、等待->就绪)。 
				
				
				
				
				
				
				
				 进程控制块的内容可以分成(调度信息)和(现场信息)两大部门。
				 
				 进程由程序、数据和进程控制块三部分组成。 
				 
				 PCB组织方式：线性方式、索引方式、链接方式。
				 
				 进程的队列： 就绪队列、等待队列、运行队列。
				 
				 
				 
				 
				 用于进程控制的原语一般有：创建进程、撤销进程、挂起进程、激活进程、阻塞进程、唤醒进程以及改变进程优先级等。
				 
				 
				 
				 在 NUIX 类操作系统中，父进程通过调用fork函数创建子进程。典型的步骤如下：
				 1、 为子进程分配一个空闲的proc结构(即进程描述符)
				 2、 赋予子进程唯一的标识PID。
				 3、 以一次一页的方式复制父进程用户地址空间。
				 4、 获得子进程继承的共享资源的指针，如打开的文件和当前工作目录等。
				 5、 子进程就绪，加入调度队列。
				 6、 对子进程返回标识符0；向父进程返回子进程的PID。 
				 
				 
				 
				 线程的定义：在引入线程的操作系统中，(线程)是进程中的一个实体，是处理器调度和分派的基本单位。
				 
				 
				 线程实现机制：(用户级线程、内核级线程、混合实现方式)。
				 
				 
				 
				 
				 (进程调度的主要功能)：记录系统中所有进程的执行状况；根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它；把处理器分配给进程。
				 
				 
				 进程调度的时机：
				 1、 正在执行的进程运行完毕。
				 2、 正在执行的进程由于某种错误而终止。
				 3、 时间片用完，即有一个进程从运行状态变为就绪状态。
				 4、 正在执行的进程调用阻塞原语将自己阻塞起来，即一个进程从运行状态进入阻塞状态。
				 5、 创建了新的进程，即有一个新的进程进入就绪队列。
				 6、 正在执行的进程调用了唤醒原语操作激活了等待资源的进程，即一个等待状态的进程变为就绪状态。
				 
				 
				 
				 进程调度算法：
				 1、 先来先服务算法
				 2、 最短进程优先算法。
				 3、 最短剩余时间优先算法。
				 4、最高响应比优先算法。 响应比Rp=(等待时间+预计运行时间)/预计运行时间=周转时间/预计运行时间。
				 5、 轮转算法。
				 6、 最高优先级算法。
				 7、 多级反馈队列算法。该法综合了先进先出调度算法、时间片轮转算法和可抢占式最高优先级算法的一种进程调度算法。 
				 
				 
				 
				 
				 
				  一般把操作系统中提供支持系统运行的各种基本操作和基础功能的一组程序模块集中安排，形成一个操作系统的核心，称为系统核心或系统内核，简称内核。
				  
				  
				  通常，内核只占操作系统代码中的一小部分，内核是操作系统总最接近裸机的部分。
				  
				  
				  
				  
				  相关进程和无关进程：在逻辑上具有某种联系的进程称为(相关进程)，在逻辑上没有任何逻辑的进程称为(无关进程)。
				  并发进程相互之间可能是无关的，也可能是相关的。
				  
				  
				  
				  
				  
				  (进程的同步)：是指进程之间一种直接的协同工作关系，一些进程相互合作，共同完成一项任务。
				  
				  
				  (进程的互斥):在系统中，许多进程常常需要共享资源，而这些资源往往要求排他性的使用，即一次只能为一个进程服务，因此，各进程间只能互斥
				  使用这些资源，进程间的这种关系就是进程的互斥。
				  
				  
				  
				  (临界区)：若在系统中某些资源一次只允许一个进程使用，则这类资源成为临界资源或共享变量，而在进程中访问临界资源的程序称为临界区。
				  
				  
				  
				  
				  
				  
				  如果有若干进程共享某一临界区，则该临界区称为(相关临界区)。
				  
				  
				  系统对相关临界区的调度使用原则归纳如下：
				  1、 当临界区为空时，若有一个进程要求进入临界区，应允许它立即进入临界区————有空让进。
				  
				  
				  
				  
				  2、 若有一个进程已在临界区时，其他要求进入临界区的进程必须等待————无空等待。
				  
				  3、 当没有进程在临界区，而同时有多个进程要求进入临界区，只能让其中之一进入临界区，其他进程必须等待————多中择一。
				  
				  
				  4、 任一进程进入临界区的要求应在有限时间满足————有限等待。
				  
				  5、 处于等待状态的进程应放弃占用处理器————让权等待。
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  (信号量)是一种特殊的变量，它的表面形式是一个整型变量附加一个队列；而且，它只能被特殊的操作(即P操作和V操作)使用。P操作和V操作都是原语。 
				  
				  
				  设信号量为S，S可以取不同的整数值。对信号量S实施的P操作和V操作，可分别用P(S)和V(S)表示。
				  
				  
				  
				  
				  P操作和V操作定义：
				  P(S)
				  {
				  S=S-1;
				  若S<0,将该进程状态置为等待状态，然后将该进程的PCB插入相应的S信号量等待队列末尾,直到有其他进程在S上执行V操作为止；
				  }
				  V(S)
				  {
				  S=S+1;
				  若S<=0;释放在S信号量队列中等待的一个进程，将其状态改变为就绪态，并将其插入就绪队列；然后，执行本操作的进程继续执行；
				  }
				  
				  
				  
				  
				   用P、V操作实现进程之间的互斥：
				   假设有进程A、B竞争进入临界区，用P、V操作实现进程之间的互斥的程序可以写成 ：
				   
				   进程A         进程B
				   P(S);           P(S);
					临界区操作;     临界区操作;
				   V(S);            V(S);
					其中，S的初值为1  
					
					
					
					
					
					
					
					
					
					
					
					
					
					用P、V操作实现进程之间的同步：
					考虑一种同步关系，其中有两个信号量S1和S2，赋予它们的初值均为0，S1表示在一个缓冲区中是否装满信息，S2表示该缓冲区中信息是否取走。程序可写成： 
					
					
					进程A        					进程B 
					 ...           					...
					 while(true){					while(true){
					 ...  							...  
					把信息送入缓冲区;			    P(S1); 
					V(S1);						    把信息送入缓冲区;
					P(S2);                           V(S2);
					 ...                             ...
					 };                              };
					 ...                              ... 
					 
					 
					 
					 
					 
					 
					 
					 
					 经典的进程同步问题：
					 1、 简单生产者————消费者问题
					 2、 多个生产者————消费者问题
					 3、 读者————写者问题 
					 
					 
					 
					 
					 
					 
					 
					 管程的概念及组成：
					 一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。一个管程由四个部分组成，
					 它们是管程名称、共享数据的说明、对数据进行操作的一组过程和对共享数据赋初值的语句。
					 
					 
					 
					 管程具有三个主要的特性：模块化、抽象数据类型、信息隐蔽。
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 解决进程之间的大量信息通信的问题有三类方案：(共享内存、消息机制以及通过共享文件进行通信，即管道通信)。
					 1、 共享内存 
					 2、 消息机制。 包括信息缓冲通信、信箱通信和管道通信。
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 (死锁)是指在多道程序系统中的一种现象，一组进程中的每一个进程均无限期地等待被该组进程中的另一个进程所占有且永远不会释放的资源。
					 系统发生这种现象称为系统处于死锁状态，简称死锁。处于死锁状态的进程称为(死锁进程)。 
					 
					 
					 
					 
					 
					 
					 
					 
					  死锁产生的原因：
					  1、 (竞争资源)，系统资源在分配时出现失误，进程间对资源的相互争夺而造成僵局。 
					  死锁是若干进程因使用资源不当而造成无法推进的现象。按照资源的使用性质，一般把系统中的资源分为两类:(永久性资源(可重用资源)), 是指系统中可供进程
					  重复使用、长期存在的资源，如内存、外部设备、处理器等硬件资源，以及各种数据文件、表格、共享程序代码等软件资源；(临时性资源(消耗性资源)),是指由
					  某个进程所产生、只为另一个进程使用一次或经过短暂时间后便不再使用的资源。以上两种资源都可能导致死锁发生。 
					  
					  2、 多道程序运行时，进程推进顺序不合理。 
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  死锁产生的必要条件：
					  1、 互斥条件
					  2、 不可剥夺条件
					  3、 请求和保持条件
					  4、 循环等待条件 
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  解决死锁的方法：预防死锁、避免死锁、检测与接触死锁、忽略死锁。
					  
					  
					  
					  
					  (死锁预防)是指在任何系统操作前(例如分配资源、调度进程等)，事先评估系统的可能情况，严格采取措施使得死锁的四个必要条件不成立。死锁预防的基本思想是防范于
					  未然。
					  
					  
					  
					  
					  
					  
					  
					  预防死锁的策略：
					  1、 资源的静态分配策略
					  2、 资源的有序分配法：采用资源有序分配策略，其基本思想是将系统中所有资源顺序编号。一般原则是，较为紧缺、稀少的资源的编号较大。进程申请资源时，
					  必须严格按照资源编号的顺序进行，否则系统不予分配。即一个进程只有得到编号小的资源，才能申请编号较大的资源；释放资源时，应按编号递减的次序进行。
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  (死锁避免的基本思想)是：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，
					  否则予以分配。这是一种保证系统不进入死锁状态的动态策略。
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  安全状态与不安全动态：安全状态是指：如果存在一个由系统所有进程构成的安全序列{P1,...Pn},则系统处于安全状态。一个进程序列{P1,...,Pn}是安全的，如果
					  对于其中每一个进程Pi(1<=i<=n),它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj(j<i)当前占有资源量之和。系统处于安全状态则(不会发生死锁)。如果
					  不存在任何一个安全序列，则系统处于(不安全状态)。不安全状态不一定导致死锁，但死锁状态一定是不安全状态。即系统若处于不安全状态则可能发生死锁。
					  
					  
					  
					  银行家算法：
					  最著名的死锁避免算法是有Dijkstra等人提出来的银行家算法。操作系统按照银行家的规定为进程分配资源，进程首先提出对资源的最大需求量，当进程在执行中每次申请
					  资源时，系统测试该进程已占用的资源与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过，则系统再测试系统现存的资源
					  能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。这样做，能保证在任何时刻至少有一个进程可以得到所需要的全部资源而执行
					  结束，执行结束后归还的资源加入到系统的剩余资源中，这些资源又至少可以满足另一个进程的最大需求，于是，可以保证系统中所有进程都能在有限的时间内得到需要的全部
					  资源。
					  
					  
					  
					  
					  
					  (死锁检测的时机)：通常，死锁检测可以在任何一次资源分配后，也可以在每次调度后，或者利用定时器定时运行检测，还有一种方法是当系统中某个进程长期位于
					  阻塞态或阻塞进程过多时，启动死锁检测程序。
					  
					  
					  (死锁检测的算法)：死锁检测的算法依不同的系统而不同。
					  
					  
					  死锁的解除方法：
					  1、 剥夺资源。经常使用的方法有：还原算法，即恢复计算结果和状态；建立检查点主要是用来恢复分配前的状态。
					  2、 撤销进程。撤销死锁进程，将它们占有的资源分配给另一些死锁进程，直到死锁解除为止。
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  资源分配图：
					  资源分配图是一张有向图，一个系统资源分配图SRAG可定义为一个二元组，即SRAG=(V,E),其中V是
					  顶点的集合，而E是有向边的集合。
					  
					  
					  死锁定理：
					  1、 如果资源分配图中没有环路，则系统没有死锁
					  2、 如果资源分配图中出现了环路，则系统中可能存在死锁。
					  
					  一、如果处于环路中的每个资源类中均只包含一个资源实例，则环路的存在即意味着死锁的存在。此时，环路是死锁的充分必要条件 
					  
					  二、如果处于环路中的每个资源类中资源实例的个数不全为1，则环路的存在是产生死锁的必要条件而不是充分条件
					  
					  
					  
					  资源分配图化简方法：
					  1、 在资源分配图中，找出一个既非等待又非孤立的进程节点Pi，由于Pi可获得它它所需要的全部资源，且运行完后释放它所占有的全部资源，
					  故可在资源分配图中消去Pi所有的申请边和分配边，使之成为既无申请边又无分配边的孤立节点。
					  
					  
					  2、 将Pi所释放的资源分配给申请它们的进程，即在资源分配图中将这些进程对资源的申请边改为分配边。
					  
					  3、 重复1、2 两步骤，直到找不到符合条件的进程结点。
					  
					  
					  经过化简后，若能消去资源分配图中的所有边，使所有进程都成为孤立结点，则该图是完全化简的；否则为不可化简的。 
					  
					  
					  
					  (哲学家加餐问题)是操作系统中关于进程同步与互斥的经典问题，也是涉及死锁的关键问题。
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  (内存空间)，是由存储单元(字节或字)组成的一维连续的地址空间，简称内存空间。内存空间一般分为两部分：一部分是(系统区)，用以存储
					  操作系统驻内存部分，用户不能占用这部分空间；另一部分是(用户区)，分配给用户使用，用于装入并存储用户程序和数据，这部分的信息随时都在发生
					  变化。存储管理实质上就是管理供用户使用的那部分空间。
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  内存分配有两种方式：
					  1、 (静态分配)，程序要求的内存空间是在目标模块连接装入内存时确定并分配的，并且在程序运行过程中不允许再申请或在内存中"搬家"，即
					  分配工作是在程序运行前一次性完成。
					  
					  2、 (动态分配)：程序要求的基本内存空间是在目标模块装入时确定并分配的，但是在程序运行过程中允许申请附加的内存空间或在内存中"搬家"，即分配
					  工作可以在程序运行前及运行过程中逐步完成。
					  
					  
					  
					  
					  存储共享：
					  是指两个或多个进程公用内存中相同区域，这样不仅能使多道程序动态地共享内存，提高内存利用率，而且还能共享内存中某个区域的信息。共享的内容包括代码
					  共享和数据共享，特别是代码共享要求代码必须是纯代码。
					  
					   存储共享的一个目的是通过代码共享节省内存空间，提高内存利用率；另一个目的是通过数据共享实现进程通信。
					   
					   存储保护的内容包括：保护系统程序区不被用户有意或无意的侵犯；不允许用户程序读写不属于自己地址空间的数据，如系统区地址空间、
					   其他用户程序的地址空间。
					   
					   
					   
					   
					   (地址重定位)：把逻辑地址转换成绝对地址的工作称"地址重定位"或"地址转换"，又称为"地址映射"。重定位的方式可以有"静态重定位"和 
					   "动态重定位" 。 
					   
					   (静态重定位)：内存在装入程序时，要把程序中指令地址和数据地址全部转换成绝对地址。由于地址转换工作是在程序开始执行前集中完成的，
					   所以在程序执行过程中就无须再进行地址转换工作，这种地址转换方式称"静态重定位" 
					   
					   
					   (动态重定位)：内存在装入程序时，不进行地址转换，而是直接把程序装入到分配的内存区域中。在程序执行过程中，每当执行一条指令时都由硬件
					   的地址转换机构将指令中的逻辑地址转换成绝对地址。这种方式的地址转换是在程序执行时动态完成的，故称为"动态重定位"
					   
					   
					   
					   
					   
					   
					   
					   
					   固定分区是指系统先把内存划分成若干个大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储要求，
					   各分区的大小可以不同。由于每一分区的大小是固定的，就对可容纳程序的大小有所限制。因此，程序运行时必须提供对内存资源的(最大申请量)
					   
					   
					   
					   
					   (可变分区)是指系统不预先划分固定分区，而是在装入程序时划分内存分区，使为程序分配的分区的大小正好等于该程序的需求量，且分区的个数是可变的。
					   显然，可变分区有较大的灵活性，较之固定分区能获得较好的内存利用率。

						 系统初启后，在内存中除操作系统区之外，其余空间为一个完整的大空闲区。当有程序要求装入内存运行时，系统从该空闲区中划分出一块与程序大小相同
						 的区域进行分配。当系统运行一段时间后，随着一系列的内存分配和回收。原来的一整块大空闲区形成了若干占用区和空闲区相间的布局。
						 若有上下相邻的两块空闲区，系统应将它们合并成为一块连续的大空闲区。
						 
						 
						 
						 紧缩技术：
						 解决碎片问题的办法是在适当时刻进行碎片整理，通过移动内存中的程序，把所有空闲碎片合并成一个连续的大空闲区且放在内存的一端，而把所有程序
						 占用区放在内存的另一端。这一技术称为"紧缩技术"或"压缩技术"。
						 
						 
						 (内存分配表)由两张表格组成。一个是(已分配区表)，记录已装入的程序在内存中占用分区的起始地址和长度，用标志位指出占用分区的程序名。
						 另一个是(空闲区表)，记录内存中可供分配的空闲区的起始地址和长度，用标志位指出该分区是未分配的空闲区。
						 
						 
						 
						 
						  操作系统查找和分配空闲区的三种分配算法：
						  1、 (最先适应算法),又称顺序分配算法，当接到内存申请时，顺序查找分区说明表，找到第一个满足申请长度的空闲区，
						  将其分割并分配。此算法简单，可以快速做出分配决定。
						  2、 (最优适应算法),当接到内存申请时， 查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其分割并分配。
						  此算法最节约空间，因为它尽量不分割大的空闲区；其缺点是可能会形成很多很小的空闲区域，称作碎片。
						  
						  3、 (最坏适应算法)，当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的基本思想是： 
						  在大空闲区中装入信息后，分割剩下的空闲区相对也很大，还能用于装入其他程序。
						  
						  
						  
						  分区管理方案的优缺点：
						  分区管理是实现多道程序设计的一种简单易行的存储管理技术。通过分区管理，内存真正成为了共享资源，有效地利用了处理器和
						  I/O设备，从而提高了系统的吞吐量和缩短了周转时间。分区存储管理算法比较简单，所采用的表格不多，实现起来比较容易，
						  内存额外开销较少，存储保护措施也很简单。
						  
						  
						   在内存利用率方面，可变分区的内存利用率比固定分区高。 
						   
						     分区管理的主要缺点是，内存使用仍不充分，并且存在着较为严重的碎片问题。虽然可以解决碎片问题，但需要移动大量信息，浪费了处理器时间。
							 此外，分区管理不能为用户提供"虚存"，即不能实现对内存的"扩充"，每一个用户程序的存储要求仍然受到物理存储器实际存储容量的限制。
							 分区管理要求运行程序一次全部装入内存之后，才能开始运行。这样，内存汇总可能包含有一些实际不使用的信息。 
							 
							 
							 
							 
							 
							 
							 
							 
							 
							   (覆盖技术)是指一个程序的若干程序段，或几个程序的某些部分共享一个存储空间。覆盖技术的实现是吧程序划分为若干个功能上相对独立的程序段，
							   按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域。未执行的程序段先保存在磁盘上，当有关程序段的前一部分执行结束后，
							   把后续程序段调入内存，覆盖前面的程序段。
							   
							   
							   (交换技术又称为对换技术)。在分时系统中，用户的进程比内存能容纳的数量要多，这就需要在磁盘上保存那些内存放不下的进程。
							   在需要运行这些进程时，再将它们装入内存。
							   
							   在实际操作系统中使用交换技术需考虑的问题：换出进程的选择、交换时机的确定、交换空间的分配、换入进程换回内存时位置的确定。
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   (虚拟存储技术的基本思想)是利用大容量的外存在扩充内存，产生一个比有限的实际内存空间大得多的、逻辑的虚拟内存空间，简称虚存，
							   以便能够有效地支持多道程序系统的实现和大型程序运行的需要，从而增强系统的处理能力。
							   
							   
							   (页式存储管理思想首先由英国曼彻斯特大学提出)，并在该校的Atlas计算机上使用。该技术近年来已广泛用于计算机系统中，支持页式存储
							   管理的硬件部件通常称为"存储管理部件"
							   
							   
							   
							   
							   
							   
							   
							   页表：
							   页表提出该程序虚拟地址中的页号与所占用的物理页面号之间的对应关系。页表的长度由程序拥有的页面数而定，故每个程序的页表长度可能是不同的。
							   
							   
							   页表又是硬件进行地址转换的依据，每执行一条指令时按虚拟地址中的页号查页表。若页表中无此页号，则产生一个"地址错"的程序性中断
							   事件。若页表中有此页号，则可得到对应的物理页面号，按计算公式可转换成访问的内存的物理地址。
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   页表的分类：
							   1、 (多级页表)：大多数操作系统中采用二级页表，即由页表页和页目录一起构成进程页表。第一级表示页目录，
							   保存页表页的地址；第二级表示页表页，保存物理页面号。
							   
							   
							   2、 (散列页表)：当地址空间大于32位时，一种常见的方法是使用以页号为散列值的散列页表。其中每个表项都包含三个字段:
							   a、虚拟页号   b、所映射的页框号   c、指向链表中下一个元素的指针。 
							   
							   3、 (反置页表)：在反置页表中，每个物理页框对应一个表项。每个表项包含与改页框相对应的虚拟页面地址，以及拥有该页面进程的信息。
							   因此，整个系统中只存在一个页表，并且每个页框对应其中一个表项。由于一方面系统中只有一个页表，而另一方面系统中又存在着
							   多个映射着物理内存的地址空间，因此需要在反置页表中存放地址空间标志符。 
							   
							   
							   
							   
							   
							   
							     转换检测缓冲区(TLB):利用高速缓冲存储器存储房钱访问最频繁的少数活动页面的页号，这个高速缓冲存储器称为(转换检测缓冲区)，
								 也称为(快表) 
								 
								 
								 
								 
								 缺页异常处理过程：
								 1、 根据当前执行指令中的
								 
								 
								 to  page 21 under 
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							   
							 
							 
							 
							 
							 
							 
							 
							 
							 
							 
							 
							 
							 
							 
						   
						   
						  
						  
						  
						  
						  
						  
						  
						  
						  
						  
						  

					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					   
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					
					
				   
				   
				   
				   
				   
				   
				   
				   
				   
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				
				
				
				
				
				
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			 
			 
			 
			 
			 
			 
			 
			 
			 
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		   
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		  
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		
		
		
		
		
		
		
		
		
		
		
	  
	  
	  
	  
	  
	  
	
	
	
	
 
 
 
   
   